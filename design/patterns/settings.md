# Settings
设置是应用内用户可以指定他们偏好的地方，决定了应用的一些行为，他们对用户有下面的好处：
* 你不需要总是询问用户同样的问题，设置之后，应用就知道在这些情况下应该怎么做。(查看设计准则：[Decide for me but let me have the final say]())
* 你可以让他们觉得自在，有控制感(查看设计准则:[Let me make it mine]())

## Flow and Structure
### Provide access to Settings in the action overflow
设置在应用内不不突出，因为他们不经常被使用。即使动作栏上有位置，也不要把设置按钮放在动作栏上。问题把他们放在动作栏扩展部分，并且标为
“设置”。把他放在除“帮助”之外的所有其它项之下。

### Avoid the tempatation to make everything a setting
由于设置在通常的导航之外，无论你有多少项，都不会打乱你 UI 的核心部分。这听起来是个好消息，但是这也带来了一些挑战。

设置可以会让你总是想在里面放很多东西——像走廊里的壁橱，在你收拾之前堆满东西。这不是一个你会花费很多时间的地方，所以你很容易忽视
杂乱的状况。但是当用户访问设置时，无论多不经常访问，他们期待像在应用的其它地方一样有相似的体验。更多的设置意味着更多的选择，过多
的内容会淹没用户。
所以不要让困难的产品决策和争吵最终演变成“在这里放一个设置吧”。对第一个你放到设置中的控制，保持符合下面的要求：

1. 它确实是用户偏好吗?(信息和动作不是用户偏好)
  - No: 不要把它放进设置里。（如果这是应用的静态信息，例如版本号，服务条款，把他们放在帮助里; 如果这是一个动作，把他们放在动作栏里）
  - Yes: 2
2. 用户经常改变他们么？(经常到他们会觉得每次访问都要进行3个步骤很费力）
  - Yes：不要把它放进设置里。（在动作栏上给它一个突出的位置，让它可以方便访问）
  - No: 3
3. 对多数用户来说，这是一个正确的答案么？（是否有80%以上的用户都会把这个设置成相同的值，并且永远不会改变？）
  - Yes: 4
  - No: 可以把它放入设置
4. 如果把这个正确答案设置成一个固定的行为，会伤害那些不能改变这些设置的小众用户么？
  - Yes: 可以把它放入设置
  - No: 不要把它放放设置

如果你有很多设置，把相似的进行分组。
人们在短时间内平均只能控制 7+-2 个项目。如果你展示了10个或者更多的设置，用户浏览，理解，处理起来就会很困难。

你可以通过把它们分组来进行弥补，把一个长列表变成多个短列表。一组相关设置可以按下面两种方式之一进行显示：
1. 在一个分节符下
2. 在一个子屏幕内

你可以用其中之一，或者都用上这两种方式来组织你的应用设置。

例如 ，在 Android 设置应用的主屏幕上，列表中的每一个项目都会进入一个相关的子屏幕内。除此之外，主屏幕的设置列表还被分节符分成多个组。

设置分组并不是严肃的科学，但是你可以根据应用内设置的总数目，按照下面的建议来分组:

* 小于等于7个：不要把他们分组，这不会对用户有好处，并且看起来还有点过了。
* 8到10个: 用1到2个分节符把相关设置分组。如果你有一些“单例”（不和其它任何设置有关），可以这样做：
  - 如果他们有一些重要设置，放在最上面，不要用分节符
  - 否则，放在最后一组里，组名为“其它”，并按重要性排序
* 11到15个：和上面的建议一样，不过是使用2到4个分节符
  - 如果2个或更多的设置是为超市用户准备的，可以把他们移出主设置界面，放在高级设置界面里。在动作栏扩展里加一个“高级”按钮进行导航。
  - 如果两个设置是相关的，但和其它设置不相关。可以试着把他们合并成一个设置，使用这节后面给出的设计模式。例如，你可以重新设计两个相关的单选项设置，做成一个多选设置。
* 16个以上：如果你有4个以上的相关设置，把他们放到一个子界面中。然后用上面的建议来减少列表大小。

## Desgin Patterns
* Checkbox: 使用这一模式去设置选或者不选
* Multiple choice: 使用这一模式显示具体的选项，用户只能从中选择一个
* Slider: 使用这一模式去设置连续值
* Date/time: 使用这一模式设置日期
* Subscreen navigation: 使用这一模式作为进入子屏幕或者子屏幕序列的导航，让用户进行更复杂的设置。
  - 如果导向一个单独的子屏幕，子屏幕的标题要和向它导航的项目内容一致
  - 如果导航到一个子屏幕序列，使用序列的第一部作为子屏幕标题的名字
* List subscreen: 使用这一模式设置那些包含等价项目的列表。标签表示项目的名字，二级文本表示状态（在这个例子中，状态使用一个右置的图标来加强）。任何与列表相关的动作出现在动作栏上，而不是列表上。
* Master on/off switch: 使用这一模式来设置整个分类的打开与关闭。开关 切换是子屏幕动作栏上的第一项。当关闭时，列表中的项会消失，取而代之的是描述为什么列表消失的文字。如果任何动作需要开关是打开的，那么这些动作会变成不可用状态。你也可以在菜单栏上显示开关，并导向子屏幕。然而，你只应该在用户设置后就很少访问的情况下才使用它，大部分时候，用户只是切换开关。
* Individual on/off switch: 使用这一模式会比 Checkbox 需要提供更多的描述。开关切换只出现在子屏幕，所以用户不看到描述信息的话就不会切换他们。出现在设置标签下方的二级文本是对当前选择的描述。在这个例子中，Android Beam 默认是打开 的。由于用户可能不知道这个设置在做什么，我们可以让这个状态比只有一个“打开”更具描述性。
* Dependency: 使用这一模式去设置那些可用性依赖于另一设置的的情况。不可用的设置在他的依赖项下面，不使用任何缩进。如果设置包含状态行，可以显示“不可用”，如果原因是不清楚的，可以在状态栏设置一个简短的描述。如果一个设置被其它多于三个项依赖，可以使用一个子屏幕，它包含一个主开关，这样可以避免屏幕中有过多的不可用项。

## Defaults
仔细考虑你的每一个选项的默认值。由于设置决定了应用的行为，你的选择决定了用户对你的应用的第一印象。虽然用户可以改变设置，但是他们仍然期待初始状态是合理的。下面的这些问题可能会对你的决定有帮助：
* 如果没有默认设置，用户最可能选择哪个？
* 哪个选择更自然或者中性？
* 哪个选择风险更小，有争议，或者有些过分？
* 哪个选择使用更小的电量或者移动数据？
* 哪个选择对设计准则 [Never lose my stuff]() 有更好的支持？
* 哪个选择对设计准则 [Only interrupt me if it's important]() 有更好的支持？


