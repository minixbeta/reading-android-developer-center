# Settings
设置是应用内用户可以指定他们偏好的地方，决定了应用的一些行为，他们对用户有下面的好处：
* 你不需要总是询问用户同样的问题，设置之后，应用就知道在这些情况下应该怎么做。(查看设计准则：[Decide for me but let me have the final say]())
* 你可以让他们觉得自在，有控制感(查看设计准则:[Let me make it mine]())

## Flow and Structure
### Provide access to Settings in the action overflow
设置在应用内不不突出，因为他们不经常被使用。即使动作栏上有位置，也不要把设置按钮放在动作栏上。问题把他们放在动作栏扩展部分，并且标为
“设置”。把他放在除“帮助”之外的所有其它项之下。

### Avoid the tempatation to make everything a setting
由于设置在通常的导航之外，无论你有多少项，都不会打乱你 UI 的核心部分。这听起来是个好消息，但是这也带来了一些挑战。

设置可以会让你总是想在里面放很多东西——像走廊里的壁橱，在你收拾之前堆满东西。这不是一个你会花费很多时间的地方，所以你很容易忽视
杂乱的状况。但是当用户访问设置时，无论多不经常访问，他们期待像在应用的其它地方一样有相似的体验。更多的设置意味着更多的选择，过多
的内容会淹没用户。
所以不要让困难的产品决策和争吵最终演变成“在这里放一个设置吧”。对第一个你放到设置中的控制，保持符合下面的要求：

1. 它确实是用户偏好吗?(信息和动作不是用户偏好)
  - No: 不要把它放进设置里。（如果这是应用的静态信息，例如版本号，服务条款，把他们放在帮助里; 如果这是一个动作，把他们放在动作栏里）
  - Yes: 2
2. 用户经常改变他们么？(经常到他们会觉得每次访问都要进行3个步骤很费力）
  - Yes：不要把它放进设置里。（在动作栏上给它一个突出的位置，让它可以方便访问）
  - No: 3
3. 对多数用户来说，这是一个正确的答案么？（是否有80%以上的用户都会把这个设置成相同的值，并且永远不会改变？）
  - Yes: 4
  - No: 可以把它放入设置
4. 如果把这个正确答案设置成一个固定的行为，会伤害那些不能改变这些设置的小众用户么？
  - Yes: 可以把它放入设置
  - No: 不要把它放放设置

如果你有很多设置，把相似的进行分组。
人们在短时间内平均只能控制 7+-2 个项目。如果你展示了10个或者更多的设置，用户浏览，理解，处理起来就会很困难。

你可以通过把它们分组来进行弥补，把一个长列表变成多个短列表。一组相关设置可以按下面两种方式之一进行显示：
1. 在一个分节符下
2. 在一个子屏幕内

你可以用其中之一，或者都用上这两种方式来组织你的应用设置。

例如 ，在 Android 设置应用的主屏幕上，列表中的每一个项目都会进入一个相关的子屏幕内。除此之外，主屏幕的设置列表还被分节符分成多个组。

设置分组并不是严肃的科学，但是你可以根据应用内设置的总数目，按照下面的建议来分组:

* 小于等于7个：不要把他们分组，这不会对用户有好处，并且看起来还有点过了。
* 8到10个: 用1到2个分节符把相关设置分组。如果你有一些“单例”（不和其它任何设置有关），可以这样做：
  - 如果他们有一些重要设置，放在最上面，不要用分节符
  - 否则，放在最后一组里，组名为“其它”，并按重要性排序
* 11到15个：和上面的建议一样，不过是使用2到4个分节符
  - 如果2个或更多的设置是为超市用户准备的，可以把他们移出主设置界面，放在高级设置界面里。在动作栏扩展里加一个“高级”按钮进行导航。
  - 如果两个设置是相关的，但和其它设置不相关。可以试着把他们合并成一个设置，使用这节后面给出的设计模式。例如，你可以重新设计两个相关的单选项设置，做成一个多选设置。
* 16个以上：如果你有4个以上的相关设置，把他们放到一个子界面中。然后用上面的建议来减少列表大小。

## Desgin Patterns
* Checkbox: 使用这一模式去设置选或者不选
* Multiple choice: 使用这一模式显示具体的选项，用户只能从中选择一个
* Slider: 使用这一模式去设置连续值
* Date/time: 使用这一模式设置日期
* Subscreen navigation: 使用这一模式作为进入子屏幕或者子屏幕序列的导航，让用户进行更复杂的设置。
  - 如果导向一个单独的子屏幕，子屏幕的标题要和向它导航的项目内容一致
  - 如果导航到一个子屏幕序列，使用序列的第一部作为子屏幕标题的名字
* List subscreen: 使用这一模式设置那些包含等价项目的列表。标签表示项目的名字，二级文本表示状态（在这个例子中，状态使用一个右置的图标来加强）。任何与列表相关的动作出现在动作栏上，而不是列表上。
* Master on/off switch: 使用这一模式来设置整个分类的打开与关闭。开关 切换是子屏幕动作栏上的第一项。当关闭时，列表中的项会消失，取而代之的是描述为什么列表消失的文字。如果任何动作需要开关是打开的，那么这些动作会变成不可用状态。你也可以在菜单栏上显示开关，并导向子屏幕。然而，你只应该在用户设置后就很少访问的情况下才使用它，大部分时候，用户只是切换开关。
* Individual on/off switch: 使用这一模式会比 Checkbox 需要提供更多的描述。开关切换只出现在子屏幕，所以用户不看到描述信息的话就不会切换他们。出现在设置标签下方的二级文本是对当前选择的描述。在这个例子中，Android Beam 默认是打开 的。由于用户可能不知道这个设置在做什么，我们可以让这个状态比只有一个“打开”更具描述性。
* Dependency: 使用这一模式去设置那些可用性依赖于另一设置的的情况。不可用的设置在他的依赖项下面，不使用任何缩进。如果设置包含状态行，可以显示“不可用”，如果原因是不清楚的，可以在状态栏设置一个简短的描述。如果一个设置被其它多于三个项依赖，可以使用一个子屏幕，它包含一个主开关，这样可以避免屏幕中有过多的不可用项。

## Defaults
仔细考虑你的每一个选项的默认值。由于设置决定了应用的行为，你的选择决定了用户对你的应用的第一印象。虽然用户可以改变设置，但是他们仍然期待初始状态是合理的。下面的这些问题可能会对你的决定有帮助：
* 如果没有默认设置，用户最可能选择哪个？
* 哪个选择更自然或者中性？
* 哪个选择风险更小，有争议，或者有些过分？
* 哪个选择使用更小的电量或者移动数据？
* 哪个选择对设计准则 [Never lose my stuff]() 有更好的支持？
* 哪个选择对设计准则 [Only interrupt me if it's important]() 有更好的支持？

## Writing Guidelines
### Label clearly and concisely
为设置名个好名字是非常有挑战的，因为空间是有限的。你只有一行，而且在最小的设备上是非常短的一行。遵循下面的准则，让你起的名字简洁，有意义，可读性好：
* 用语句的方式给设置起名字（只在首字母和合适的名词下大字）
* 不要让设置的名字以命令式的词开始，例如，设置，改变，编辑，调整，管理，使用，选择。用户已经知道这些东西是用来设置的。
* 类似地，不要让名字以“设置”结尾
* 如果设置是分组的一部分，不要重复分节符和子界面标题中已经出现的词
* 避免以负面的词开始，例如“不要”，“永远不要”。例如，“不要允许”可以修改为“阻止”
* 避免使用技术术语，除非目标用户对此很熟悉。使用常用的词语来表达设置的目的，而不是底层的技术
* 不要引用用户。例如，对一个是否通知用户的设置，起名为“通知”，而不是“通知我”

一旦你决定了设置的名字，在 [LDPI handset]() 上预览，保证他们在任何地方都是合适的。

### Secondary text below is for status, not description...
在 Ice Cream Sandwich之前，我们总是在设置名下显示二级文本，作进一步的描述或者提供指导。从 Ice Cream Sandwich 之后，我们使用二级文本来表示状态。

在二级文本中显示状态有下列好处：
* 用户可以直接在二级文本中看到当前的设置值，而不用通过导航
* 适用于设计准则 [Keep it brief]()，用户会非常喜欢这种状态

### unless it's a checkbox setting
使用二级文本表示状态有一个非常重要的例外：checkbox 设置。在这里，使用二级文本用来描述，而不是表示状态。checkbox 下的状态描述 是没有必要的，因为 checkbox 已经表达了它。之所以要在 checkbox 下使用描述是因为，与其它控件不同，它不会导向另一个对话框或者界面，因而无法提供进一步的信息。

这就是说，如果 checkbox 设置名自己就已经很清楚了，就没必要提供描述了。只在有必要时才包含描述。

使用下面的指导来写 checkbox  的描述：
* 保持为一句话，不要用结束标点
* 要传达出选择之后会发生什么，发命令式的词语来表示。例如：“允许数据改变”，而不是“会允许数据改变”
* 避免重复标签中已经存在的词语
* 不要引用人称除非这对用户理解设置非常重要
* 如果你一定要使用人称，使用“你”，而不是“我”。Android 在对用户讲话，而不是代表用户。

### Writing examples
下面的例子是我们在 Ice Cream Sandwich 中对系统设置应用的名字和二级文本作出的改变。

* Before: Use tactile feedback
* After: Vibrate on touch

在 checkbox 设置中，我们避免使用了 Use，而让名字变得更直接，易懂。

* Before: Screen timeout(Adjust the delay before the screen automatically turns off)
* After: Sleep(After 10 minutes of inactivity)

在这个多选择设置中，我们把设置名改的更友好，还把二级文本改成了状态描述 。我们把描述词语围绕着选择的值,"10分钟”，因为如果只有“10分钟”，那么用户可能误解为“睡眠十分钟”

* Before: Change screen lock(Change or disable pattern, PIN, or password security)
* After: Screen lock(Pattern)

这一设置导向子界面序列，允许用户在多个锁屏选项中选择一个并进行设置。我们避免使用“改变”作为设置名的开始，而是直接描述锁屏的类型。如果用户没有设置锁屏，二级文本可以设置为“无”

* Before: NFC(Use Near Field Communication to read and exchange tags)
* After: NFC(Allow data exchange when the phone touches another device)

在这个 checkbox 设置中，虽然使用技术术语，但是我们仍然使用 “NFC”，因为：（1）我们无法找到一个更清楚，简洁的替代品，（2）使用熟悉的缩写，在接下来的几年中会急速增加

我们重写了描述信息。它没有之前的描述技术性强，描述了如何以及为什么使用 NFC。我们没有将什么是 NFC 写在描述里，因为对多数用户来说这没有意义还占地方。

## Checklist
* 保证设置里的第一项都符合这里的标准
* 如果你有多于7项设置，寻找分组方式
* 使用合适的设计模式，这样会降低用户的学习成本
* 选择安全，自然，对多数用户合适的选项作为默认值
* 给每个设置一个清楚，简洁的名字，使用合适的二级文本
