Application Fundamentals
Andorid 应用使用 Java 语言完成。Android SDK 工具可以将你的源代码，以及数据文件，资源文件编译成 APK: Android 应用包，它是以 .apk
后缀结尾的文件。一个 APK 文件包含了Android应用的所有内容，Android 使用它来安装应用。

一旦应用安装到设备中，每个应用都存活在自己的安全沙箱中:
* Android 操作系统是一个多用户的 Linux 系统，每个应用都是一个不同的用户
* 默认情况下，系统分配给每个应用一个 Linux 用户ID(这个ID只被系统使用，应用不知道它的存在）。系统为每个应用内的文件设置权限，这样
只有赋予那个应用的用户 ID才能访问他们
* 每个进程都有它自己的虚拟机(VM)，这样应用的代码可以与其它应用隔离运行
* 默认情况下，每个应用运行在它自己的 Linux 进程中。当应用内的任何一个组件需要执行时，Android 会启动一个进程。当不需要时或者系统
必需为其它应用回收内存时，会关闭进程。

通过这种方式，Android 系统实在 了最小权限原则。每个应用默认情况下只能访问它完成工作所需要的组件，不能访问更多的东西。这就创建了
一个安全的环境，应用在里面不能访问它没有被赋予权限的部分。

然而，仍然有一些方式 ，让应用之间可以分享数据，让应用可以访问系统服务：
* 可能让两个应用分享同一个 Linux 用户ID，这样他们就可以访问彼此的文件。为了保留系统资源，有相同用户 ID 的应用可以运行在同一个
Linux 进程下，共享虚拟机（应用必须以同样的认证来登入）
* 应用可以请求权限，来访问设备中的数据，例如用户联系人，短信，SD卡，摄像头，蓝牙等等。所有的应用权限必须在应用被安装时
被用户授权。

上面的内容包含了与 Android 应用如何存在于系统中相关的基本知识。文档下面的部分会介绍：
* 定义应用的核心框架组件
* 用于声明组件以及所需要的应用特性的 manifest 文件

## App components
应用组件是 Android 应用的基本模块。每个组件都是一个不同的点，通过他们系统可以进入你的应用。不是所有的组件对用户来说都是进入点，
有些相互依赖，但是每一个都独立存在，扮演着特殊的角色，每一个都是一个独立的组件，帮助你定义应用的所有行为。

有四种不同类型的应用组件。每种都有不同的目的，不同的生命周期，定义了组件如何创建和销毁。

这里有四种类型的应用组件：

### 活动（Activities)
活动代表包含用户接口的界面。例如，一个邮件应用可能包含一个显示所有邮件列表的活动，另一个活动用来编写邮件，还有一个活动用来阅读邮件。虽然活动在一起工作，共同组成邮件应用中的用户体验，但是每一个与其它活动都是独立的。同样地，其它应用可以启动其中任何一个组件（只要邮件应用允许）。例如，照相应用可以启动邮件应用中的活动，用于编辑新邮件，用户分享图片。

活动是 [Activity]() 类的子类，你可以在 [Activities]() 开发者指南中学到更多的信息。

### 服务(Services)
服务是运行在后台执行长时间动作或者执行远程操作的组件。服务并不提供用户接口。例如，服务可能在后台播放音乐，而此时用户可能在另一个应用中，或者服务正在通过网络获取数据，不会打扰用户和活动的交互。另一个组件，例如活动，可以启动一个服务，让它运行，或者绑定到它，以便与它交互。

### 内容提供器（Content providers)
内容提供器管理应用可以被分享的数据。你可以把数据存储在文件系统中，SQLite数据库中，存在web上，或者其它你的应用可以访问的永久
存储介质中。通过内容提供器，其它应用可以查询或者修改其中的数据（如果内存提供器允许）。例如，Android 系统通过内容提供器来管理
联系人数据，其它应用如果有相应权限，可以通过内容提供器来查询修改联系人中的数据。

内容提供器在读写那些应用的私有数据时特别有用。例如，Sample 中的 [Note Pad]() 使用内容提供器来保存笔记。

内容提供器是 [ContentProvider]() 的子类，必须实现一组标准的 API 集，提供给其它应用使用。更多信息，参见 [Content Providers]() 开发者指南。

### 广播接收器（Broadcast receivers)
广播接收器用来对系统内的广播作出响应。许多广播都是由系统发起的，例如，广播表明屏幕关闭，电量低，照片已经捕获。应用也可以初始化广播，例如，告诉其它应用下载完成了，你们可以用了。虽然广播接收器并不显示用户接口，但是他们可以 [创建状态栏通知]()，告诉用户广播事件的发生。更一般地，广播接收器对其它组件来说就是一种“通道”，用来作非常少量的工作。例如它可能基于某个事件，初始化服务，用于执行一个任务。

广播接收器是 [BroadcastReceiver]() 的子类，每个广播都作为 [Intent]() 对象来传播。更多信息，可以参见 [BroadcastReceiver]() 类。

Android 系统设计的一个独特之处在于任何应用都可以启动其它应用中的组件。例如你的应用要拍一张照片，你不用自己实现一个活动用来拍照，你可以在你的应用中直接启动照相机应用中的活动。照相机应用中的活动拍照完成后，会把结果返回给你的应用。用户使用时，就想照相机应用属于你的应用的一部分一样。

当系统启动一个组件时，它会单独为这个组件启动一个进程（如果之前没有启动的话）。例如，你的应用使用照相机应用来拍照，那么拍照的活动在照相机应用所在的进程中，并不在你的应用所在的进程中。因此，与其它系统中的应用不同，Android 应用并没有一个统一的入口点（例如 main 函数）。

由于每个应用都在一个单独的进程中，不同应用之间有权限的限制，所以你不能直接激活其它应用中的组件，但是Android系统本身可以。所以，在 Android 系统中，当你想启动其它应用中的组件时，你可以启动一个 **意图(intent)**，告诉 Android 系统你想启动一个组件。系统会为你启动它。

## Activating Components
四种组件中的三种——活动，服务，广播接收器，都是通过被称为**意图(intent)** 的异步消息来激活的。意图会绑定到组件中，无论这组播组件是否属于你的应用。你可以把意图当成信使，他们会请求来自其它应用的动作。

意图通过 [Intent]() 对象创建 ，定义了需要激活的特定组件或者某种类型的组件。

对活动和服务来说，意图定义了要执行的动作（例如，“查看”或者“发送”），也可能会指定需要施加动作的数据的 URI(被启动的组件需要知道这些 ）。例如，一个意图可能传递出一个请求，启动一个显示图片或者打开网页的活动。一些情况下，你可以启动意图并获取结果，在这种情况下，活动加返回一个结果，结果也在一个意图中（例如，你可以请求一个意图，记用户选择一个联系人，然后返回给你——返回的意图包含了指向用户选择的联系人的 URI)。

对广播接收器来说，意图只是定义了需要广播的消息（例如，表示电量低的广播只包含一个已知的动作字符串“电池低”）

其它的组件类型，内容提供器，不被意图激活。它被一个来自 [ContentResolver]() 的请求激活。内容解析器用来处理与内容提供器直接相关的事务，这样向提供器执行动作的组件就没必要直接与其交互，而是通过 [ContentResolver]() 对象来调用方法。这就在内容提供器和请求信息的组件之间形成了一个抽象层（为了安全）。

下面是激活各种类型组件的函数：

* 你可以将 [Intent]() 传递给 [startActivity]() 或者 [startActivityForResult]() 来启动活动。
* 你可以通过将 [Intent]() 传递给 [startService]() 来启动服务。或者你也可以通过向 [bindService]() 传递 [Intent]() 进行绑定。
* 你可以将 [Intent]() 传递给 [sendBroadcast]() 或者 [sendOrderedBroadcase]()或者 [sendStickyBroadcast]() 来初始化广播。
* 你可以在 [ContentResolver]() 上调用 [query()]() 来向内容提供器执行一个请求。

更多关于使用意图的信息，可以参见 [Intents and Intents Filters]() 文档。更多关于激活特定组件的信息，也可以参考 [Activities](), [Services](), [BroadcastReceiver](), 以及 [Content Providers]().

## The Manifest File
在 Android 系统启动你的应用中的组件之前，它需要通过 AndroidManifest.xml 文件知道你的应用中都有哪些组件。你需要在这个文件中声明所有组件，并且把这个文件放到应用目录的顶层。

除了声明组件外，Manifest 文件还可以：
* 识别应用需要的用户权限，例如网络访问或者读取用户联系人。
* 基于应用使用的 API, 声明应用需要的最小 API 等级。
* 声明应用需要的软硬件特性，例如照相机，蓝牙服务或者多点触控屏幕。
* 应用需要链接到的 API 库，除了Android 框架的 API 外，例如 [Goolge Mpas library]().

### Declaring components
Manifest 文件的主要任务就是通知系统应用包含的组件。例如，一个 manifest 文件示例：

```
<?xml version="1.0" encoding="utf-8"?>
<manifest ...>
  <application android:icon="drawable/app_icon.png" ...>
    <activity android:name="com.example.project.ExampleActivity"
              android:label="@string/example_label" ...>
    </activity>
    
    ...
  <application>
</manifest>
```

在 <application> 元素中，android:icon 属性指向代表应用的图标资源。
在 <activity> 元素中，android:name 属性指定了一个 Activity 子类的全名，android:label 属性指定了用户可见的活动名称。

你必须以下面的方式声明所有应用的组件:

* <activity> 元素代表活动
* <service> 元素代表服用
* <receiver> 元素代表广播接收器
* <proivder> 元素代表内容提供器

活动，服务及内容提供器如果没有在 Manifest 文件中声明 ，系统是看不到他们的，因此是不能运行的。然而，广播接收器可以在 Manifest 文件中声明，也可以使用代码动态生成，通过 registerReceiver 调用。

更多关于如何结构化应用 Manifest 文件的信息，可以参见 [The AndroidManifest.xml]() 文档。

### Declaring component capabilities
我们在之前提到，你可以使用意图来启动活动，服务以及广播接收器。你可以在意图中使用组件的名字显示地指定要启动的组件。但是意图的真正力量在于隐式意图。你只需要指定一个要执行的动作，由系统去搜索设备上哪个应用的组件可以响应这个动作，如果有多个组件可以响应，则可以让用户从中选择一个。

系统去识别哪些组件可以响应意图的方式是，将收到的意图与 Manifest 文件中的 **意图过滤器** 进行比较。在 Manifest 文件中声明活动时，可以同时指定这个活动可以响应的意图，使用 `intent-filter` 来完成。

例如，如果你构建了一个邮件应用，其中有一个活动可以编写新邮件，你可以声明一个意图过滤器，去响应“发送”意图：

```
<manifest ...>
  ...
  <application ...>
    <activity android:name="com.example.project.CompostEmailActivity">
      <intent-filter>
        <action android:name="android.intent.action.SEND" />
        <data android:type="*/*" />
        <category android:name="android.intent.category.DEFAULT" />
      </intent-filter>
    </activity>
  </application>
</manifest>
```

这样，如果其它应用创建一个包含 `ACTION_SEND` 的意图，传递给 `startActivity`，那么系统就可能启动你的活动，让用户来编辑发送邮件。

更多关于意图过滤器的信息，可以参考 [Intents and Intent Filters]() 文档。

### Declaring app requirements
支持 Andorid 的设备有很多，他们有着不同的特性和能力。为了避免让你的应用安装在那些没有应用所需特性的设备上，在 Manifest 文件中清楚地定义你的应用支持的设备的特性是非常重要的。对多数声明来说，系统不会读取他们，但是这些声明对于像 Google Play 这样的外部服务是非常有用的，Google Play 可以通过这些声明，在用户搜索应用时作出过滤。

例如，如果你的应用需要摄像头，使用 Android 2.1(API Level 7) 中引入的 API，你需要在 Manifest 文件中这样声明：

<manifest ...>
  <uses-feature andorid:name="android.hardware.camera.any"
                android:required="true" />
  <uses-sdk android:minSdkVersion="7" android:targetrSdkVersion="19"/>
  ...
</manifest>

这样，那些没有摄像头或者 Android 版本低于 2.1 的设备就不能通过 Google Play 安装你的应用。

然而，如果你想声明你的应用需要摄像头，但是不是必须的，那么，可以将 `required` 属性修改为 `false`，并且自己在应用代码中检查是否有摄像头，如果没有的话关闭一些特性。

更多关于管理应用兼容性的信息，可以参见 [Device Compatibility]() 文档。

### App Resources
应用不仅是由代码构成的，它还需要与源代码分享的资源，例如图片，声音文件以及其它与视觉展示相关的东西。例如，你应该使用 XML 文件定义动画，菜单，风格，颜色以及活动布局。使用应用资源可以让你在不改变代码的情况下更新应用的各种特征——通过对不同设备配置（例如语言，屏幕大小）提供不同的资源文件。

每一个你包含到 Android 项目中的资源，SDK 构建工具都会定义一个独立 的整数 ID，你可以在代码中使用它们去引用 XML 文件中定义的资源。例如，如果你的应用包含一个 logo.png 图片文件（在 res/drwable/ 目录下），那么  SDK 工具会生成名为 R.drawable.logo 的资源 ID，你可以使用它们去引用图片，插入到用户接口中。

让资源独立于代码，最重要的一方面是让你可以对不同配置的设备提供不同的资源。例如，通过在 XML 文件中定义 UI 字符串，你可以翻译成另一种语言，然后在另一个文件中定义。那么，根据你定义资源目录名字的标识符（例如 res/values-fr 代表法国）以及用户的语言设置，Android 系统会在你的 UI 中使用不同的字符串。

Android 支持许多不同的标识符，用于代表不同的资源。标识符是用于资源目录的短小的字符串，指明了你想把这个资源用于哪种配置。例如，你可以根据设备屏幕的方向和大小，为活动定义不同的布局。比如为横向屏幕定义的按钮是水平的，为竖向屏幕定义的按钮是竖直方向的。你可以使用不同的标识符去定义两种不同的布局，这样在用户手机横向时，系统会加载横向标识符目录下的布局，在用户手机纵向时，系统会加载纵向标识符目录下布局。

更多关于资源文件的介绍，以及如何为不同配置的设备提供不同布局的信息，可以参考 [Prividing Resources]().
